Next, we interpolate missing values by first defining all the variables that need to be interpolated: `pratio9050`, `pratio5010`, `pratio9050s`, `pratio5010s`, `pforeign`, and `pvoc`. To interpolate missing values for each country, rather than for the dataset as a whole, we write a loop to define the object `data_countries` as a list of the data (with these aforementioned new variables) subsetted by each country.
At this point, we can interpolate missing values for each variable. The `zoo` package allows use to use the function `na.approx` to linearly interpolate missing values. We use a set of loops that interpolates missing values indexed for each country, `i`, in our list of `data.frames`, `data_countries`, *for each variable*.[^1] Finally, we can use `rbind` to bind this new list into a single `data.frame`, and remove our list of `data.frames`.
[^1]: This is what `data_countries[[i]][,y>23]` refers to, where `i` is each country and `y` represents the new variables. The 24th column is `pratio9050`, the 25th column `pratio5010`, and so on. Each of these are interpolated using the original variables, which are represented in `data_countries[[i]][,z>5]`, where `z` represents the original variables corresponding the new variables (i.e. `pratio9050` is interpolated using `ratio9050`, which is in the 5th column, and so on). Note that the index along which the function is operating is by year (`data_contries[[i]][,3]`) for *every* variable. In other words, we are replacing the variables of interest in each country for missing years.
```{r}
library('zoo')
data_countries <- lapply(unique(data$country), function(x)
subset(data, data$country==x)
)
for (i in 1:length(data_countries)){
data_countries[[i]] <- cbind(data_countries[[i]], sapply(c(5:8, 16, 19), function(y)
na.approx(data_countries[[i]][,y], x = index(data_countries[[i]][,3], data_countries[[i]][,y]), na.rm = FALSE)
))
}
data <- do.call("rbind", data_countries)
names(data)[24:29] <- c("pratio9050", "pratio5010", "pratio9050s", "pratio5010s", "pforeign", "pvoc")
rm(data_countries)
```
We generate an immigration measure, `fpop` which reflects the percentage of the population that is foreign-born by using our interpolated measure `pforeign`, multiplying it by 1000, and dividing this result by `pop`, which is total population.
```{r}
data$pforeign <- data$pforeign*1000
data$fpop <- data$pforeign/data$pop
```
Our last data cleaning step before moving on to generating the averages for the redistribution models is to generate additional measures of inequality as defined by manipulations to our existing measures of inequality: `ratio9010`, `ratio9010s`, `skew`, and `skews`.
```{r}
data$ratio9010 <- data$pratio9050*data$pratio5010
data$ratio9010s <- data$pratio9050s*data$pratio5010s #not extrapolated
data$skew <- data$pratio9050/data$pratio5010
data$skews <- data$pratio9050s/data$pratio5010s #not extrapolated
```
Because data on redistribution are unequally spaced for the period of the study, the authors use a time series cross sectional model where the indepdent variables are averaged across the period since the last redistribution observation.
We generate moving averages for the redistribution models by using a series of loops. First we generate the `since` variable, which represents the years since the last redistribution, `redist`, for each country. We remake our list of the subset of countries as before and define `since` (`data_countries[[i]][35]`) accordingly by creating a new logical vector, `nona`, that tells us when the `redist` variable is and is not defined for each country.
```{r}
data_countries <- lapply(unique(data$country), function(x)
subset(data, data$country==x)
)
for (i in 1:length(data_countries)){
data_countries[[i]] <- cbind(data_countries[[i]], NA)
nona <- !is.na(data_countries[[i]][,4])
data_countries[[i]][,35][nona] <- c(NA, diff(data_countries[[i]][,3][nona]))
}
data <- do.call("rbind", data_countries)
names(data)[35] <- "since"
rm(data_countries)
```
Now we can calculate the moving averages:
```{r}
library('dplyr')
# Calculate moving average for ratio9010 (var31)
data_countries <- lapply(unique(data$country), function(x)
subset(data, data$country==x)
)
for (i in 1:length(data_countries)){
for (j in 1:10) {
data_countries[[i]][,35+j] <- lag(rollapply(data_countries[[i]][,31], j, FUN = mean, fill = NA, align = "right"),1)
}
}
data <- do.call("rbind", data_countries)
for(x in 37:ncol(data)){
# Nested loop starts from first row
for(y in 2:nrow(data)){
# Check for NA
if(is.na(data[y,x])){
data[y,x] <- data[y,x-1]
}
}
}
data$dvratio9010 <- NA
data[,46] <- case_when(
data[,35] %in% 1 ~ data[,36],
data[,35] %in% 2 ~ data[,37],
data[,35] %in% 3 ~ data[,38],
data[,35] %in% 4 ~ data[,39],
data[,35] %in% 5 ~ data[,40],
data[,35] %in% 6 ~ data[,41],
data[,35] %in% 7 ~ data[,42],
data[,35] %in% 8 ~ data[,43],
data[,35] %in% 9 ~ data[,44],
data[,35] %in% 10 ~ data[,45]
)
data[,46][is.na(data[,35]) & !is.na(data[,4])] <- data[,45][is.na(data[,35]) & !is.na(data[,4])]
data <- data[,c(0:35,46)]
# Calculate moving average for pratio9050 (var24)
data_countries <- lapply(unique(data$country), function(x)
subset(data, data$country==x)
)
for (i in 1:length(data_countries)){
for (j in 1:10) {
data_countries[[i]][,35+1+j] <- lag(rollapply(data_countries[[i]][,24], j, FUN = mean, fill = NA, align = "right"),1)
}
}
data <- do.call("rbind", data_countries)
for(x in c(37+1):ncol(data)){
# Nested loop starts from first row
for(y in 2:nrow(data)){
# Check for NA
if(is.na(data[y,x])){
data[y,x] <- data[y,x-1]
}
}
}
data$dvpratio9050 <- NA
data[,46+1] <- case_when(
data[,35] %in% 1 ~ data[,36+1],
data[,35] %in% 2 ~ data[,37+1],
data[,35] %in% 3 ~ data[,38+1],
data[,35] %in% 4 ~ data[,39+1],
data[,35] %in% 5 ~ data[,40+1],
data[,35] %in% 6 ~ data[,41+1],
data[,35] %in% 7 ~ data[,42+1],
data[,35] %in% 8 ~ data[,43+1],
data[,35] %in% 9 ~ data[,44+1],
data[,35] %in% 10 ~ data[,45+1]
)
data[,46+1][is.na(data[,35]) & !is.na(data[,4])] <- data[,45+1][is.na(data[,35]) & !is.na(data[,4])]
data <- data[,c(0:(35+1),46+1)]
# Calculate moving average for pratio5010 (var25)
data_countries <- lapply(unique(data$country), function(x)
subset(data, data$country==x)
)
for (i in 1:length(data_countries)){
for (j in 1:10) {
data_countries[[i]][,35+2+j] <- lag(rollapply(data_countries[[i]][,25], j, FUN = mean, fill = NA, align = "right"),1)
}
}
data <- do.call("rbind", data_countries)
for(x in c(37+2):ncol(data)){
# Nested loop starts from first row
for(y in 2:nrow(data)){
# Check for NA
if(is.na(data[y,x])){
data[y,x] <- data[y,x-1]
}
}
}
data$dvpratio5010 <- NA
data[,46+2] <- case_when(
data[,35] %in% 1 ~ data[,36+2],
data[,35] %in% 2 ~ data[,37+2],
data[,35] %in% 3 ~ data[,38+2],
data[,35] %in% 4 ~ data[,39+2],
data[,35] %in% 5 ~ data[,40+2],
data[,35] %in% 6 ~ data[,41+2],
data[,35] %in% 7 ~ data[,42+2],
data[,35] %in% 8 ~ data[,43+2],
data[,35] %in% 9 ~ data[,44+2],
data[,35] %in% 10 ~ data[,45+2]
)
data[,46+2][is.na(data[,35]) & !is.na(data[,4])] <- data[,45+2][is.na(data[,35]) & !is.na(data[,4])]
data <- data[,c(0:(35+2),46+2)]
# Calculate moving average for stdpjoint (var22)
data_countries <- lapply(unique(data$country), function(x)
subset(data, data$country==x)
)
for (i in 1:length(data_countries)){
for (j in 1:10) {
data_countries[[i]][,35+3+j] <- lag(rollapply(data_countries[[i]][,22], j, FUN = mean, fill = NA, align = "right"),1)
}
}
data <- do.call("rbind", data_countries)
for(x in c(37+3):ncol(data)){
# Nested loop starts from first row
for(y in 2:nrow(data)){
# Check for NA
if(is.na(data[y,x])){
data[y,x] <- data[y,x-1]
}
}
}
data$dvstdpjoint <- NA
data[,46+3] <- case_when(
data[,35] %in% 1 ~ data[,36+3],
data[,35] %in% 2 ~ data[,37+3],
data[,35] %in% 3 ~ data[,38+3],
data[,35] %in% 4 ~ data[,39+3],
data[,35] %in% 5 ~ data[,40+3],
data[,35] %in% 6 ~ data[,41+3],
data[,35] %in% 7 ~ data[,42+3],
data[,35] %in% 8 ~ data[,43+3],
data[,35] %in% 9 ~ data[,44+3],
data[,35] %in% 10 ~ data[,45+3]
)
data[,46+3][is.na(data[,35]) & !is.na(data[,4])] <- data[,45+3][is.na(data[,35]) & !is.na(data[,4])]
data <- data[,c(0:(35+3),46+3)]
# Calculate moving average for skew (var33)
data_countries <- lapply(unique(data$country), function(x)
subset(data, data$country==x)
)
for (i in 1:length(data_countries)){
for (j in 1:10) {
data_countries[[i]][,35+4+j] <- lag(rollapply(data_countries[[i]][,33], j, FUN = mean, fill = NA, align = "right"),1)
}
}
data <- do.call("rbind", data_countries)
for(x in c(37+4):ncol(data)){
# Nested loop starts from first row
for(y in 2:nrow(data)){
# Check for NA
if(is.na(data[y,x])){
data[y,x] <- data[y,x-1]
}
}
}
data$dvskew <- NA
data[,46+4] <- case_when(
data[,35] %in% 1 ~ data[,36+4],
data[,35] %in% 2 ~ data[,37+4],
data[,35] %in% 3 ~ data[,38+4],
data[,35] %in% 4 ~ data[,39+4],
data[,35] %in% 5 ~ data[,40+4],
data[,35] %in% 6 ~ data[,41+4],
data[,35] %in% 7 ~ data[,42+4],
data[,35] %in% 8 ~ data[,43+4],
data[,35] %in% 9 ~ data[,44+4],
data[,35] %in% 10 ~ data[,45+4]
)
data[,46+4][is.na(data[,35]) & !is.na(data[,4])] <- data[,45+4][is.na(data[,35]) & !is.na(data[,4])]
data <- data[,c(0:(35+4),46+4)]
# Calculate moving average for stddisp_gall (var23)
data_countries <- lapply(unique(data$country), function(x)
subset(data, data$country==x)
)
for (i in 1:length(data_countries)){
for (j in 1:10) {
data_countries[[i]][,35+5+j] <- lag(rollapply(data_countries[[i]][,23], j, FUN = mean, fill = NA, align = "right"),1)
}
}
data <- do.call("rbind", data_countries)
for(x in c(37+5):ncol(data)){
# Nested loop starts from first row
for(y in 2:nrow(data)){
# Check for NA
if(is.na(data[y,x])){
data[y,x] <- data[y,x-1]
}
}
}
data$dvstddisp_gall <- NA
data[,46+5] <- case_when(
data[,35] %in% 1 ~ data[,36+5],
data[,35] %in% 2 ~ data[,37+5],
data[,35] %in% 3 ~ data[,38+5],
data[,35] %in% 4 ~ data[,39+5],
data[,35] %in% 5 ~ data[,40+5],
data[,35] %in% 6 ~ data[,41+5],
data[,35] %in% 7 ~ data[,42+5],
data[,35] %in% 8 ~ data[,43+5],
data[,35] %in% 9 ~ data[,44+5],
data[,35] %in% 10 ~ data[,45+5]
)
data[,46+5][is.na(data[,35]) & !is.na(data[,4])] <- data[,45+5][is.na(data[,35]) & !is.na(data[,4])]
data <- data[,c(0:(35+5),46+5)]
# Calculate moving average for pvoc (var29)
data_countries <- lapply(unique(data$country), function(x)
subset(data, data$country==x)
)
for (i in 1:length(data_countries)){
for (j in 1:10) {
data_countries[[i]][,35+6+j] <- lag(rollapply(data_countries[[i]][,29], j, FUN = mean, fill = NA, align = "right"),1)
}
}
data <- do.call("rbind", data_countries)
for(x in c(37+6):ncol(data)){
# Nested loop starts from first row
for(y in 2:nrow(data)){
# Check for NA
if(is.na(data[y,x])){
data[y,x] <- data[y,x-1]
}
}
}
data$dvpvoc <- NA
data[,46+6] <- case_when(
data[,35] %in% 1 ~ data[,36+6],
data[,35] %in% 2 ~ data[,37+6],
data[,35] %in% 3 ~ data[,38+6],
data[,35] %in% 4 ~ data[,39+6],
data[,35] %in% 5 ~ data[,40+6],
data[,35] %in% 6 ~ data[,41+6],
data[,35] %in% 7 ~ data[,42+6],
data[,35] %in% 8 ~ data[,43+6],
data[,35] %in% 9 ~ data[,44+6],
data[,35] %in% 10 ~ data[,45+6]
)
data[,46+6][is.na(data[,35]) & !is.na(data[,4])] <- data[,45+6][is.na(data[,35]) & !is.na(data[,4])]
data <- data[,c(0:(35+6),46+6)]
# Calculate moving average for union (var12)
data_countries <- lapply(unique(data$country), function(x)
subset(data, data$country==x)
)
for (i in 1:length(data_countries)){
for (j in 1:10) {
data_countries[[i]][,35+7+j] <- lag(rollapply(data_countries[[i]][,12], j, FUN = mean, fill = NA, align = "right"),1)
}
}
data <- do.call("rbind", data_countries)
for(x in c(37+7):ncol(data)){
# Nested loop starts from first row
for(y in 2:nrow(data)){
# Check for NA
if(is.na(data[y,x])){
data[y,x] <- data[y,x-1]
}
}
}
data$dvunion <- NA
data[,46+7] <- case_when(
data[,35] %in% 1 ~ data[,36+7],
data[,35] %in% 2 ~ data[,37+7],
data[,35] %in% 3 ~ data[,38+7],
data[,35] %in% 4 ~ data[,39+7],
data[,35] %in% 5 ~ data[,40+7],
data[,35] %in% 6 ~ data[,41+7],
data[,35] %in% 7 ~ data[,42+7],
data[,35] %in% 8 ~ data[,43+7],
data[,35] %in% 9 ~ data[,44+7],
data[,35] %in% 10 ~ data[,45+7]
)
data[,46+7][is.na(data[,35]) & !is.na(data[,4])] <- data[,45+7][is.na(data[,35]) & !is.na(data[,4])]
data <- data[,c(0:(35+7),46+7)]
# Calculate moving average for fpop (var30)
data_countries <- lapply(unique(data$country), function(x)
subset(data, data$country==x)
)
for (i in 1:length(data_countries)){
for (j in 1:10) {
data_countries[[i]][,35+8+j] <- lag(rollapply(data_countries[[i]][,30], j, FUN = mean, fill = NA, align = "right"),1)
}
}
data <- do.call("rbind", data_countries)
for(x in c(37+8):ncol(data)){
# Nested loop starts from first row
for(y in 2:nrow(data)){
# Check for NA
if(is.na(data[y,x])){
data[y,x] <- data[y,x-1]
}
}
}
data$dvfpop <- NA
data[,46+8] <- case_when(
data[,35] %in% 1 ~ data[,36+8],
data[,35] %in% 2 ~ data[,37+8],
data[,35] %in% 3 ~ data[,38+8],
data[,35] %in% 4 ~ data[,39+8],
data[,35] %in% 5 ~ data[,40+8],
data[,35] %in% 6 ~ data[,41+8],
data[,35] %in% 7 ~ data[,42+8],
data[,35] %in% 8 ~ data[,43+8],
data[,35] %in% 9 ~ data[,44+8],
data[,35] %in% 10 ~ data[,45+8]
)
data[,46+8][is.na(data[,35]) & !is.na(data[,4])] <- data[,45+8][is.na(data[,35]) & !is.na(data[,4])]
data <- data[,c(0:(35+8),46+8)]
# Calculate moving average for fempar (var10)
data_countries <- lapply(unique(data$country), function(x)
subset(data, data$country==x)
)
for (i in 1:length(data_countries)){
for (j in 1:10) {
data_countries[[i]][,35+9+j] <- lag(rollapply(data_countries[[i]][,10], j, FUN = mean, fill = NA, align = "right"),1)
}
}
data <- do.call("rbind", data_countries)
for(x in c(37+9):ncol(data)){
# Nested loop starts from first row
for(y in 2:nrow(data)){
# Check for NA
if(is.na(data[y,x])){
data[y,x] <- data[y,x-1]
}
}
}
data$dvfempar <- NA
data[,46+9] <- case_when(
data[,35] %in% 1 ~ data[,36+9],
data[,35] %in% 2 ~ data[,37+9],
data[,35] %in% 3 ~ data[,38+9],
data[,35] %in% 4 ~ data[,39+9],
data[,35] %in% 5 ~ data[,40+9],
data[,35] %in% 6 ~ data[,41+9],
data[,35] %in% 7 ~ data[,42+9],
data[,35] %in% 8 ~ data[,43+9],
data[,35] %in% 9 ~ data[,44+9],
data[,35] %in% 10 ~ data[,45+9]
)
data[,46+9][is.na(data[,35]) & !is.na(data[,4])] <- data[,45+9][is.na(data[,35]) & !is.na(data[,4])]
data <- data[,c(0:(35+9),46+9)]
# Calculate moving average for unempl (var11)
data_countries <- lapply(unique(data$country), function(x)
subset(data, data$country==x)
)
for (i in 1:length(data_countries)){
for (j in 1:10) {
data_countries[[i]][,35+10+j] <- lag(rollapply(data_countries[[i]][,11], j, FUN = mean, fill = NA, align = "right"),1)
}
}
data <- do.call("rbind", data_countries)
for(x in c(37+10):ncol(data)){
# Nested loop starts from first row
for(y in 2:nrow(data)){
# Check for NA
if(is.na(data[y,x])){
data[y,x] <- data[y,x-1]
}
}
}
data$dvunempl <- NA
data[,46+10] <- case_when(
data[,35] %in% 1 ~ data[,36+10],
data[,35] %in% 2 ~ data[,37+10],
data[,35] %in% 3 ~ data[,38+10],
data[,35] %in% 4 ~ data[,39+10],
data[,35] %in% 5 ~ data[,40+10],
data[,35] %in% 6 ~ data[,41+10],
data[,35] %in% 7 ~ data[,42+10],
data[,35] %in% 8 ~ data[,43+10],
data[,35] %in% 9 ~ data[,44+10],
data[,35] %in% 10 ~ data[,45+10]
)
data[,46+10][is.na(data[,35]) & !is.na(data[,4])] <- data[,45+10][is.na(data[,35]) & !is.na(data[,4])]
data <- data[,c(0:(35+10),46+10)]
# Calculate moving average for turnout (var13)
data_countries <- lapply(unique(data$country), function(x)
subset(data, data$country==x)
)
for (i in 1:length(data_countries)){
for (j in 1:10) {
data_countries[[i]][,35+11+j] <- lag(rollapply(data_countries[[i]][,13], j, FUN = mean, fill = NA, align = "right"),1)
}
}
data <- do.call("rbind", data_countries)
for(x in c(37+11):ncol(data)){
# Nested loop starts from first row
for(y in 2:nrow(data)){
# Check for NA
if(is.na(data[y,x])){
data[y,x] <- data[y,x-1]
}
}
}
data$dvturnout <- NA
data[,46+11] <- case_when(
data[,35] %in% 1 ~ data[,36+11],
data[,35] %in% 2 ~ data[,37+11],
data[,35] %in% 3 ~ data[,38+11],
data[,35] %in% 4 ~ data[,39+11],
data[,35] %in% 5 ~ data[,40+11],
data[,35] %in% 6 ~ data[,41+11],
data[,35] %in% 7 ~ data[,42+11],
data[,35] %in% 8 ~ data[,43+11],
data[,35] %in% 9 ~ data[,44+11],
data[,35] %in% 10 ~ data[,45+11]
)
data[,46+11][is.na(data[,35]) & !is.na(data[,4])] <- data[,45+11][is.na(data[,35]) & !is.na(data[,4])]
data <- data[,c(0:(35+11),46+11)]
rm(data_countries)
```
Now, we match these moving averages to redistribution observations by creating a new set of independent variables with values that correspond to the correct moving average based on the period of redistribution. There are three possible scenarios here:
1) A redistribution observation is observed 1 year after the previous: the independent variable takes on its 1-year lagged value.
2) A redistribution observation is observed n years ago, where n is [2,10]: the independent variable takes on its nth year moving average value.
3) A redstribution observation is the first observation for the country: the indpeendnet variable takes on its 10th year moving average value.
Social Spending: To estimate the model using the 2nd dependent variable (socspend), we create five-year moving averages for this variable and all independent variables in the vector `c(20, 26:27, 32, 34, 21, 15, 22:23, 10:13, 29:30)`, that is `c("ma_socspend", "ma_pratio9050s", "ma_pratio5010s", "ma_pratio9010s", "ma_skews", "ma_dreher", "ma_pop65", "ma_stdpjoint", "ma_stddisp_gall", "ma_fempar", "ma_unempl", "ma_union", "ma_turnout", "ma_pvoc", "ma_fpop"`  to represent a slow-moving causal process.
```{r}
data <- cbind(data, sapply(c(20, 26:27, 32, 34, 21, 15, 22:23, 10:13, 29:30), function(x)
(lag(data[,x], 1)+lag(data[,x], 2)+lag(data[,x], 3)+lag(data[,x], 4)+lag(data[,x], 5))/5
))
names(data)[48:62] <- c("ma_socspend", "ma_pratio9050s", "ma_pratio5010s", "ma_pratio9010s", "ma_skews", "ma_dreher", "ma_pop65", "ma_stdpjoint", "ma_stddisp_gall", "ma_fempar", "ma_unempl", "ma_union", "ma_turnout", "ma_pvoc", "ma_fpop")
```
# Design declaration
We start by loading in the `DeclareDesign` package and defining the elements of the design.
* `declare_population` refers to the sample size of the study. The study concerns country-year units. In this case, there are 858 observations.
* `declare_potential_oucomes` refers to
```{r}
library('DeclareDesign')
# X: take some parameters based on a simple model of X on Y
modX <- lm(data$redist ~ data$skew)
a_X <- summary(modX)$coefficients["(Intercept)","Estimate"]
b_X <- summary(modX)$coefficients["data$skew","Estimate"]
sd_X <- 1
rho_XY <- -.5 # Confounding
sd_X_type <- .1 # sd on effect heterogeneity
sd_Y_type <- .005 # sd on compliance heterogeneity
rho_XY_type <- 0 # Possible correlation between compliance and effects
```
```{r}
population <- declare_population(
N = 858,
redist = sample(data$redist, N, replace = TRUE),
u_X = rnorm(N, sd = sd_X),
u_X_type = rnorm(N, df = sd_X_type)
)
```
```{r}
fx <- function(a_X, b_X, u_X_type, u_X)
a_X + (b_X + u_X_type) + u_X
potentials <- declare_step(handler = fabricate,
redist = fx(skew, a_X, b_X, u_X_type, u_X))
```
```{r}
estimand <- declare_estimand(
ols = mean((fx(max(skew), a_X, b_X, u_X_type, u_X) - fx(min(skew), a_X, b_X, u_X_type, u_X))/(max(skew) - min(skew))))
```
```{r}
estimator_1 <- declare_estimator(redist ~ skew, estimand = "ols",
model = lm_robust, label = "lm")
```
```{r}
lupu_pontusson_2011_design <- population + potentials + estimand + estimator_1
```
View(fx)
View(range01)
View(fx)
